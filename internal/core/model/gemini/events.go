package gemini

import (
	"github.com/ClareAI/astra-voice-service/pkg/logger"
	"go.uber.org/zap"
)

// handleModelEvent processes server events from Gemini.
func (h *Handler) handleModelEvent(connectionID string, event map[string]interface{}) {
	eventType, _ := event["type"].(string)

	switch eventType {
	case "setupComplete":
		logger.Base().Info("Gemini setup complete", zap.String("connection_id", connectionID))
		h.onModelReady(connectionID)

	case "serverContent":
		h.handleServerContent(connectionID, event)

	case "toolCall":
		h.handleToolCall(connectionID, event)

	default:
		logger.Base().Debug("Received Gemini event", zap.String("type", eventType), zap.String("connection_id", connectionID))
	}
}

// handleServerContent processes content generated by Gemini.
func (h *Handler) handleServerContent(connectionID string, event map[string]interface{}) {
	serverContent, ok := event["serverContent"].(map[string]interface{})
	if !ok {
		return
	}

	// Extract modelTurn
	modelTurn, ok := serverContent["modelTurn"].(map[string]interface{})
	if ok {
		parts, _ := modelTurn["parts"].([]interface{})
		for _, part := range parts {
			partMap, ok := part.(map[string]interface{})
			if !ok {
				continue
			}

			// Handle text
			if text, ok := partMap["text"].(string); ok {
				h.handleModelText(connectionID, text)
			}

			// Handle audio
			if inlineData, ok := partMap["inlineData"].(map[string]interface{}); ok {
				if data, ok := inlineData["data"].(string); ok {
					h.handleModelAudio(connectionID, data)
				}
			}
		}
	}

	// Handle interruption
	if _, ok := serverContent["interrupted"]; ok {
		h.handleInterruption(connectionID)
	}

	// Manage silence timer
	if turnComplete, ok := serverContent["turnComplete"].(bool); ok && turnComplete {
		h.BaseHandler.ResetSilenceTimer(connectionID)
	}
}

// handleToolCall processes function calls from Gemini.
func (h *Handler) handleToolCall(connectionID string, event map[string]interface{}) {
	toolCall, ok := event["toolCall"].(map[string]interface{})
	if !ok {
		return
	}

	functionCalls, _ := toolCall["functionCalls"].([]interface{})
	for _, fc := range functionCalls {
		fcMap, ok := fc.(map[string]interface{})
		if !ok {
			continue
		}
		h.executeFunctionCall(connectionID, fcMap)
	}
}
